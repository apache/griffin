/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package org.apache.griffin.measure.rule

import org.apache.griffin.measure.rule.expr._

case class RuleAnalyzer(rule: StatementExpr) extends Serializable {

  val constData = ""
  private val SourceData = "source"
  private val TargetData = "target"

  val constCacheExprs: Iterable[Expr] = rule.getCacheExprs(constData)
  private val sourceCacheExprs: Iterable[Expr] = rule.getCacheExprs(SourceData)
  private val targetCacheExprs: Iterable[Expr] = rule.getCacheExprs(TargetData)

  private val sourcePersistExprs: Iterable[Expr] = rule.getPersistExprs(SourceData)
  private val targetPersistExprs: Iterable[Expr] = rule.getPersistExprs(TargetData)

  val constFinalCacheExprs: Iterable[Expr] = rule.getFinalCacheExprs(constData).toSet
  private val sourceFinalCacheExprs: Iterable[Expr] = rule.getFinalCacheExprs(SourceData).toSet ++ sourcePersistExprs.toSet
  private val targetFinalCacheExprs: Iterable[Expr] = rule.getFinalCacheExprs(TargetData).toSet ++ targetPersistExprs.toSet

  private val groupbyExprPairs: Seq[(Expr, Expr)] = rule.getGroupbyExprPairs((SourceData, TargetData))
  private val sourceGroupbyExprs: Seq[Expr] = groupbyExprPairs.map(_._1)
  private val targetGroupbyExprs: Seq[Expr] = groupbyExprPairs.map(_._2)

  val sourceRuleExprs: RuleExprs = RuleExprs(sourceGroupbyExprs, sourceCacheExprs,
    sourceFinalCacheExprs, sourcePersistExprs)
  val targetRuleExprs: RuleExprs = RuleExprs(targetGroupbyExprs, targetCacheExprs,
    targetFinalCacheExprs, targetPersistExprs)

  val whenClauseExprOpt: Option[WhenClauseExpr] = rule.whenClauseOpt

}


// for a single data source
// groupbyExprs: in accuracy case, these exprs could be groupby exprs
//                  Data keys for accuracy case, generated by the equal statements, to improve the calculation efficiency
// cacheExprs: the exprs value could be caculated independently, and cached for later use
//                  Cached for the finalCacheExprs calculation, it has some redundant values, saving it wastes a lot
// finalCacheExprs: the root of cachedExprs, cached for later use, plus with persistExprs
//                  Cached for the calculation usage, and can be saved for the re-calculation in streaming mode
// persistExprs: the expr values should be persisted, only the direct selection exprs are persistable
//                  Persisted for record usage, to record the missing data, need be readable as raw data
case class RuleExprs(groupbyExprs: Seq[Expr],
                     cacheExprs: Iterable[Expr],
                     finalCacheExprs: Iterable[Expr],
                     persistExprs: Iterable[Expr]
                    ) extends Serializable {
  // for example: for a rule "$source.name = $target.name AND $source.age < $target.age + (3 * 4)"
  // in this rule, for the target data source, the targetRuleExprs looks like below
  // groupbyExprs: $target.name
  // cacheExprs: $target.name, $target.age, $target.age + (3 * 4)
  // finalCacheExprs: $target.name, $target.age + (3 * 4), $target.age
  // persistExprs: $target.name, $target.age
}