/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package org.apache.griffin.measure.batch.rule

import org.apache.griffin.measure.batch.rule.expr._

case class RuleAnalyzer(rule: StatementExpr) extends Serializable {

  val constData = ""
  private val SourceData = "source"
  private val TargetData = "target"

  val constCacheExprs: Iterable[Expr] = rule.getCacheExprs(constData)
  private val sourceCacheExprs: Iterable[Expr] = rule.getCacheExprs(SourceData)
  private val targetCacheExprs: Iterable[Expr] = rule.getCacheExprs(TargetData)

  private val sourcePersistExprs: Iterable[Expr] = rule.getPersistExprs(SourceData)
  private val targetPersistExprs: Iterable[Expr] = rule.getPersistExprs(TargetData)

  val constFinalCacheExprs: Iterable[Expr] = rule.getFinalCacheExprs(constData).toSet
  private val sourceFinalCacheExprs: Iterable[Expr] = rule.getFinalCacheExprs(SourceData).toSet ++ sourcePersistExprs.toSet
  private val targetFinalCacheExprs: Iterable[Expr] = rule.getFinalCacheExprs(TargetData).toSet ++ targetPersistExprs.toSet

  private val groupbyExprPairs: Seq[(Expr, Expr)] = rule.getGroupbyExprPairs((SourceData, TargetData))
  private val sourceGroupbyExprs: Seq[Expr] = groupbyExprPairs.map(_._1)
  private val targetGroupbyExprs: Seq[Expr] = groupbyExprPairs.map(_._2)

  private val whenClauseExprOpt: Option[LogicalExpr] = rule.getWhenClauseExpr

  val sourceRuleExprs: RuleExprs = RuleExprs(sourceGroupbyExprs, sourceCacheExprs,
    sourceFinalCacheExprs, sourcePersistExprs, whenClauseExprOpt)
  val targetRuleExprs: RuleExprs = RuleExprs(targetGroupbyExprs, targetCacheExprs,
    targetFinalCacheExprs, targetPersistExprs, whenClauseExprOpt)

}


// for a single data source
// groupbyExprs: in accuracy case, these exprs could be groupby exprs
//                  Data keys for accuracy case, generated by the equal statements, to improve the calculation efficiency
// cacheExprs: the exprs value could be caculated independently, and cached for later use
//                  Cached for the finalCacheExprs calculation, it has some redundant values, saving it wastes a lot
// finalCacheExprs: the root of cachedExprs, cached for later use, plus with persistExprs
//                  Cached for the calculation usage, and can be saved for the re-calculation in streaming mode
// persistExprs: the expr values should be persisted, only the direct selection exprs are persistable
//                  Persisted for record usage, to record the missing data, need be readable as raw data
// whenClauseExprOpt: when clause of rule, to determine if the row of data source is filtered
//                  Can be prep-calculated to filter some data in data connector
case class RuleExprs(groupbyExprs: Seq[Expr],
                     cacheExprs: Iterable[Expr],
                     finalCacheExprs: Iterable[Expr],
                     persistExprs: Iterable[Expr],
                     whenClauseExprOpt: Option[LogicalExpr]
                    ) {
  // for example: for a rule "$source.name = $target.name AND $source.age < $target.age + (3 * 4)"
  // in this rule, for the target data source, the targetRuleExprs looks like below
  // groupbyExprs: $target.name
  // cacheExprs: $target.name, $target.age, $target.age + (3 * 4)
  // finalCacheExprs: $target.name, $target.age + (3 * 4), $target.age
  // persistExprs: $target.name, $target.age
  // whenClauseExprOpt: None
}